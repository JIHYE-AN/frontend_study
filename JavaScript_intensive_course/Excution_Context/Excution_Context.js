/* 실행 콘텍스트 */
// 함수가 실행되는 영역, 묶음
// 함수 코드를 실행하고 실행 결과를 저장 예) 변수에다가 값을 할당하거나, 다른 함수를 호출해서 리턴값을 저장하거나
// 개발자가 실행 콘텍스트를 가지고 조종할 수는 없고 엔진이 처리하는 것
function music(title) {
  var musicTitle = title;
};
music("음악");
// music("음악")으로 함수를 호출하면 엔진인 실행 콘텍스트를 생성 -> 실행 콘텍스트 안으로 이동
// 실행 콘텟스트 실행 단계: 준비 단계, 초기화 단계, 코드 실행 단계
// 실행 콘텍스트 생성 시점 : 실행 가능한 코드를 만났을때 ( 함수 코드, 글로벌 코드, eval 코드)
// 코드 유형을 분리한 이유? 실행 콘텍스트에서 처리하는 방법과 실행 환경이 다르기 때문 즉, 엔진 관점에서 접근한 것
// 함수코드 : 렉시컬 환경, 글로벌 코드: 글로벌 환경, eval 코드: 동적 환경

/* 실행 콘텍스트 상태 컨포넌트 */
// 실행 콘텍스트 상태를 위한 오브젝트로 실행 콘텍스트 안에 생성
// 상태 컴포넌트 유형
/* 실행 콘텍스트(EC): {
    렉시컬 환경 컴포넌트(LEC): { },
    변수 환경 컴포넌트(VEC): { },
    this 바인딩 컴포넌트(TBC): { }
  } */
// 렉시컬 환경과 변수 환경의 초기값은 같다. -> 별도로 나눈 이유는 : 복원을 하기 위한 것 변수 환경의 초깃값을 렉시컬 환경에 설정하기 위한 것

/* 렉시컬 환경 컴포넌트 */
// 함수와 변수의 식별자 해결을 위한 환경 설정한다.
// 함수 초기화 단계에서 해석한 함수와 변수를 {name: value} 형태로 저장한다.
// 변수는 {변수이름 : undefined}로 함수는 {함수이름 : function Object}로 저장된다.
// 이름으로 함수와 변수를 검색할 수 있게 된다!
// 함수 밖의 함수와 변수 참조 환경 설정 즉, 내가 속한 오브젝트의 환경을 여기다 설정한다.
// 렉시컬 환경 컴포넌트안에서 함수 밖의 함수와 변수를 사용할 수 있게된다. 즉 하나의 콘텍스트가 되는 것
// 함수 안에 있는 것과 함수 밖에 있는 것을 하나의 묶음으로 렉시컬 환경 컴포넌트에다가 만드는 것 -> 엔진이 심플해진다.

/* 렉시컬 환경 컴포넌트 구성 */
// 렉시컬 환경 컴포넌트 생성 : function, with, try-catch문을 만났을 때 생성된다.
/* 실행 콘텍스트(EC): {
    렉시컬 환경 컴포넌트(LEC): {
      환경 레코드(ER): {
        point: 100
      },
      외부 렉시컬 환경 참조(OLER): {
        title: "책",
        getTitle: function(){}
      }
    }
  } */
// 환경 레코드에 함수 안의 함수와 변수를 기록한다.
// 외부 렉시컬 환경 참조에 function 오브젝트의 [[Scope]]를 설정한다.
// 함수 안과 밖의 함수와 변수를 하나의 콘텍스트의 개념으로 사용할 수 있게된다.
// 엔진이 심플하다 = 처리 시간이 빠르다.

/* 외부 렉세컬 환경 참조 */
// 스코프와 실행중인 함수가 Context 형태이므로 스코프의 변수와 함수를 별도의 처리 없이 즉시 사용할 수 있다.
// 실행 콘텍스트에서 함수 안과 밖의 함수, 변수를 사용할 수 있으므로 함수와 변수를 찾기 위해 실행 콘텍스트를 벗어 나지 않아도 된다.

/* 변수 환경 컴포넌트 */
// 실행 콘텍스트 초기화 단계에서 렉시컬 환경 컴포넌트와 같게 설정한다 => 렉시컬이 처리하는 메인인데 렉시컬에 설정된 것을 똑같이 변수 환경 컴포넌트에 설정한다는 것!
// 이유는? 초깃값을 복원할 때 사용하기 위한 것
// 함수 코드가 실행되면 실행 결과를 렉시컬 환경 컴포넌트에 설정
// 렉시컬 환경 컴포넌트에 있던 것을 싹 지우고 초기환경으로 바꿀려고 할때 변수 환경 컴포넌트를 사용한다. (with문에서 사용)

/* 실행 콘텍스트 실행 과정 */
var base = 200;
function getPoint(bonus) {
  var point = 100;
  return point + base + bonus;
};
console.log(getPoint(70));
// 1. getPoint 오브젝트의 [[Scope]]에 글로벌 오브젝트 설정
// 2. 마지막 줄에서 getPoint() 함수 호출
// 3. 엔진은 실행 콘텍스트를 생성하고 실행 콘텍스트 안으로 이동
// 준비단계....
// 4. 컨포넌트를 생성하여 실행 콘텍스트에 첨부 ( 렉시컬 환경 컴포넌트, 변수 환경 컴포넌트, this 바인딩 컴포넌트)
// 5. 환경 레코드를 생성하여 렉시컬 환경 컴포넌트에 첨부 - 함수 안의 함수, 변수를 바인딩
// 6. 외부 렉시컬 환경 참조를 생성하여 렉시컬 환경 컴포넌트에 첨부 (function 오브젝트의 [[Scope]]를 설정)
/* 실행 콘텍스트(EC): {
    렉시컬 환경 컴포넌트(LEC): {
      환경 레코드(ER): {},
      외부 렉시컬 환경 참조(OLER): {
        base: 200
      }
    },
    변수 환경 컴포넌트(VEC): { },
    this 바인딩 컴포넌트(TBC): { }
  } */
// 초기화 단계.....
// 6. 호출한 함수의 파라미터 값을 호출된 함수의 파라미터 이름에 매핑 환경 레코드에 작성
// 7. 함수 선언문을 fucntion 오브젝트로 생성
// 8. 함수 표현식과 변수에 초기값 설정
// 9. 여기까지는 외부에 실행 상태를 제공하지 않음
/* 실행 콘텍스트(EC): {
    렉시컬 환경 컴포넌트(LEC): {
      환경 레코드(ER): {
        bonus: 70,
        point: undefined
      },
      외부 렉시컬 환경 참조(OLER): {
        base: 200
      }
    },
    변수 환경 컴포넌트(VEC): { },
    this 바인딩 컴포넌트(TBC): { }
  } */
// 실행 단계.....
// 10. 함수 안의 코드를 실행 var point=100;
// 11. 실행 콘텍스트 안에서 관련된 함수와 변수를 사용할 수 있음

/* 환경 레코드 */
/* 환경 레코드 구성 */
// 환경 레코드를 구분하는 이유? 기록 대상에 따라 다르기 때문
// 선언적 환경 레코드(DER): function, 변수, catch문에서 사용! 앞 절에서 환경 레코드에 설정한다고 했는데 실제로는 선언적 환경 레코드에 설정된 것
// 오브젝트 환경 레코드(OER): 글로벌 함수와 변수, with 문에서 사용! 정적이 아니라 동적
// 정적인 것은 선언적 환경 레코드에 기록하고 동적인 것은 오브젝트 환경 레코드에 기록한다.

/* 글로벌 환경 */
// 글로벌 오브젝트에서 사용. 렉시컬 환경 컴포넌트와 형태가 같다. (다만 정적이 아니라 동적이라는 것!)
/* 실행 콘텍스트(EC): {
    글로벌 환경(GE): {
      환경 레코드(ER): {
        오브젝트 환경 레코드: 글로벌 오브젝트
      },
      외부 렉시컬 환경 참조(OLER): null
    }
  } */
// 동적으로 함수와 변수 바인딩 함수에서 var키워드를 사용하지 않고 변수를 선언하면 글로벌 오브젝트에 설정되기 때문
// 정적으로 사용한 것과는 차이가 많다. 정적은 한번 설정하면 바뀌지 않는데 동적은 뜬금없이 튀어나온다. 그러면 정적 개념이 깨진다.
// 할 수 있는 배경은? 글로벌 오브젝트는 소스 전체를 통해서 하나만 있다. 그래서 글로벌 환경은 하나만 만들어 놓으면 어느 코드에서 라도 동적으로 저장할 수있다.
// 글로벌 오브젝트는 어디에 속하지 않으므로 외부 렉시컬 환경 참조 값은 null이다.

/* this 바인딩 컴포넌트 */
// 목적 : this로 함수를 호출한 오브젝트의 프로퍼티에 악세스 하는것! this.popertyName 형태로 악세스 할 수 있도록 this로 악세스할 오브젝트를 바인딩 시켜 놓는다.
// 악세스 메커니즘은 obj.book()형태에서 this로 obj를 참조할 수 있도록 this 바인딩 컴포넌트에 obj 참조를 설정한다.
// obj의 프로퍼티가 변경되면 동적으로 참조 -> 설정이 아닌 참조이기 때문!
// obj는 현재 실행중인 함수의 소유가 아니다. 즉 함수안에 작성된 코드가 아니다. 따라서 함수가 실행되는 도중에 obj의 프로퍼티가 삭제되거나 변경될 수 있다.
// 그런데 그 것을 설정 개념으로 묶어놓으면 동적으로 반영되지 않는다. this로 참조할 수 있는 오브젝트를 바인딩만 시켜놓는다. 묶어놓는 것! 프로퍼티는 묶지 않고 오브젝트 자체만 묶는다.
// 현재 실행중인 함수에서 사용하는 시점에 최종적으로 반영된 값을 사용할 수 있게된다. 이것이 바인딩이다. 

/* getPoint() 함수에서 100이 반환되는 과정 */
var obj = {point: 100};
obj.getPoint = function(){
  return this.point;
};
obj.getPoint();
// 준비단계....
// 1. 마지막 줄에서 obj.getPoint() 함수 호출
// 2. 실행 콘텍스트 생성
// 3. 3개의 컨포넌트 생성
// 4. this 바인딩 컴포넌트에 getPoint()에서 this로 obj의 프로퍼티를 사용할 수 있도록 바인딩
// 초기화 단계....
// 5. 파라미터, 함수 선언문, 변수 선언 없음
// 실행 단계....
// 6. return this.point; 실행
// 7. this 바인딩 컴포넌트에서 point 검색 getPoint() 함수를 호출한 오브젝트가 this 바인딩 컴포넌트에 참조된 상태
// 8. this 바인딩 컴포넌트에 point 프로퍼티가 있으므로 100을 반환!
// ** this 바인딩 컴포넌트에 바인딩되도록 의도적으로 설계해야한다!! *
/* 실행 콘텍스트(EC): {
    렉시컬 환경 컴포넌트(LEC): {
      환경 레코드(ER): {
        선언적 환경 레코드(DER): {},
        오브젝트 환경 레코드(OER): {}
      },
      외부 렉시컬 환경 참조(OLER): {}
    },
    변수 환경 컴포넌트(VEC): { },
    this 바인딩 컴포넌트(TBC): {
      point: 100,
      getPoint: function(){}
    }
  } */

/* 호출 스택(call stack) */
// 실행 콘텍스트의 논리적 구조 (계단식으로 만드는 것)
// First In Last Out 순서
// 함수가 호출되면 스택의 가장 위에 실행 콘텍스트가 위치하게 된다.
// 다시 함수 안에서 함수를 호출하면 호출된 함수의 실행 콘텍스트가 스택의 가장 위에 놓이게 된다.
// 가장 위에 있는 것이 실행하고 있는 함수이며 실행 콘텍스트이다.
// 함수가 종료되면 스택에서 빠져나온다. 최종적으로 호출된것이 먼저나온다.
// 이런 논리가 되는 것은 자바스크립은 싱글스레드여서 그런다. 실행되는 루트가 하나다. 길이 하나이므로 이런 논리가 되는 것

/* 파라미터 매핑 */
// 함수가 호출되면 3개의 파라미터 값을 실행 콘텍스트로 넘겨준다. (함수를 호출한 오브젝트, 함수코드, 호출한 함수의 파라미터 값)
// 함수를 호출한 오브젝트: this 바인딩 컴포넌트에 설정하여 this로 참조
// 함수 코드: function 오브젝트의 [[Code]]에 설정되어 있음
// 호출한 함수의 파라미터 값: 호출된 함수의 Argument 오브젝트에 설정

/* 파라미터 값 매핑 */
// 호출한 함수에서 넘겨 준 파라미터 값을 호출된 함수의 파라미터 작성 순서에 맞춰 값을 매핑하는 것
// 엔진 처리 관점 : 실행 콘텍스트로 넘겨 준 파라미터 값과 function 오브젝트의 [[FormalParameters]]에 작성된 이름에 값을 매핑하고 결과를 선언적 환경 레코드에 설정하는 것
// [[FormalParameters]]는 호출된 함수의 파라미터에 작성된 이름이 여기에 들어가 있다.
// 언제 만들어 지느냐? function키워드를 만나서 function오브젝트를 만들때 설정된다.

/* 파라미터 값 할당 기준 */
var obj = {};
obj.getTotal = function(one, two){
  var one;
  console.log(one + two);
  two = 77;
  console.log("two:" + two);
}
obj.getTotal(11, 22);





