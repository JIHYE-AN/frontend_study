/** 실행 콘텍스트 실행 과정 정리 시간 
 * 123이 console에 출력되는 과정 정리
 * 실행 콘텍스트 관점에서 논리적으로 전개
*/

function book() {
  function get() {
    return point;
  };
  var point = 123;
  return get();
};
console.log(book());

/* 실행 콘텍스트 실행 과정 */
// 1. book오브젝트의 [[Scope]]를 글로벌 오브젝트에 설정한다.
// 2. 마지막 줄에서 book()함수를 호출
// 3. 엔진은 실행 콘텍스트를 생성하고 실행 콘텍스트 안으로 이동한다.
// 준비단계......
// 4. 컴포넌트를 생성하고 실행 콘텍스트 안에 첨부한다.
/* 실행 콘텍스트(EC): {
  렉시컬 환경 컴포넌트(LEC): {},
  변수 환경 컴포넌트(VEC): {},
  this 바인딩 컴포넌트(TBC): {}
} */
// 5. 환경 레코드를 생성하여 렉시컨 환경 컴포넌트에 첨부한다. -> 함수안의 함수, 변수를 바인딩
/* 실행 콘텍스트(EC): {
  렉시컬 환경 컴포넌트(LEC): {
    환경 레코드(ER):{}
  },
  변수 환경 컴포넌트(VEC): {},
  this 바인딩 컴포넌트(TBC): {}
} */
// 6. 외부 렉시컬 환경 참조를 생성하여 렉시컬 환경 컴포넌트에 첨부
/* 실행 콘텍스트(EC): {
  렉시컬 환경 컴포넌트(LEC): {
    환경 레코드(ER):{},
    외부 렉시컬 환경 참조(OLER): {}
  },
  변수 환경 컴포넌트(VEC): {},
  this 바인딩 컴포넌트(TBC): {}
} */
// 초기화 단계.......
// 7. 함수 선언문을 function 오브젝트로 생성
// 8. 변수에 초기값 설정
// 9. 여기까지는 외부에 실행 상태를 제공하지 않음
/* 실행 콘텍스트(EC): {
  렉시컬 환경 컴포넌트(LEC): {
    환경 레코드(ER):{
      get: return point;
      point: undefined
    },
    외부 렉시컬 환경 참조(OLER): {}
  },
  변수 환경 컴포넌트(VEC): {},
  this 바인딩 컴포넌트(TBC): {}
} */
// 실행 단계......
// 함수 안의 코드를 실행 var point: 123;
/* 실행 콘텍스트(EC): {
  렉시컬 환경 컴포넌트(LEC): {
    환경 레코드(ER):{
      get: return point;
      point: 123
    },
    외부 렉시컬 환경 참조(OLER): {}
  },
  변수 환경 컴포넌트(VEC): {},
  this 바인딩 컴포넌트(TBC): {}
} */
// 11. 실행 콘텍스트 안에서 관련된 함수와 변수를 사용할 수 있음
// point: 123 이므로 get()함수는 123을 반환하고 book은 get()함수의 값을 반환하므로 123이 최종 반환된다.


/** 파라미터 값 할당 기준 정리 시간!
 * 아래 코드를 기준으로 엔진 관점에서 [ 실행 결과]에 출력된 값의 논리를 제시하라.
 * 함수의 파라미터 값이 매핑되는 과정을 {ket: value} 형태로 기술하고 값이 출력되는 논리를 생각(기술)하라.
 * 두 번째, 세 번째 파라미터 이름이 같다. 
 */
var obj = {};
obj.getTotal = function(one, two, two){
  console.log(one + two);
}
obj.getTotal(11, 22, 55);
// 초기화 단계....
// 1. getTotal(11,22,55) 함수가 호출되면 실행 콘텍스트가 생성되고 3개의 파라미터 값(함수를 호출한 오브젝트, 함수코드, 호출한 함수의 파라미터 값)을 실행 콘텍스트로 넘겨준다.
// 2. 호출한 함수에서 넘겨준 파라미터 값을 호출된 함수의 파라미터 작성 순서에 맞춰 값을 매핑한다.
// - function 오브젝트가 생성할때 설정된 [[FormalParameters]]에 호출된 함수의 파라미터에 작성된 이름이 ["one", "two", "two"]형태로 들어가 있다.
// 3. [[FormalParameters]] 배열을 하나씩 읽는다.
// 4. 호출한 함수의 파라미터 값은 index 번째의 값을 구한다. [0: 11, 1: 22, 2: 55]
// 5. 호출된 함수의 파라미터 이름과 호출한 함수의 파라미터 값을 맵핑하여 선언적 환경 레코드에 아래와 같은 형태로 설정한다.
// - {one:11, two:22, two:55} 이렇게 설정되어야 같은 이름을 파라미터가 있다!
// - 그러므로 다시 생각을 하면 순서대로 매핑이 되므로 one과 11이 매핑이되고 그다음으로 two와 22가 매핑이된다. 그 다음 순서인 55가 매핑이 되어야 하는데 같은 이름이 존재한다. 고로 two의 값이 22 -> 55로 변경되며 매핑이 된다.
// - {one:11, two:22, two:55}은 맞지않은 형태이고 {one:11, two:55}가 최종적 형태이다.
// 6. 함수 안에는 초기화할 코드가 없으므로 첫 번째 줄로 이동하며 함수 코드를 실행한다.
// 실행 단계.....
// 7. 선언적 환경 레코드의 형태 : {one: 11, two: 55}
// 8. console.log(one + two);
// - 선언적 환경 레코드에서 one과 two의 값을 구한다. 
// - one은 11이고 two는 55이므로 one + two = 66
// - 결과인 66이 실행 결과로 출력된다. 




