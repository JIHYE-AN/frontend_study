/* 스코프 */
// 범위를 제한하여 식변자를 해결하려는 것이 목적이다.
// 스코프의 사전적 의미는 범위, 영역이다.
// 식별자 해결 : 변수 이름, 함수 이름을 찾는 것! 이때 스코프를 사용
// 스코프의 궁극적인 목적은 값을 구하는 것!
// 크게는 이름을 설정하는 것도 식별자 해결이라 할 수 있음 -> 우리가 변수 이름을 스코프에 등록하면 이것은 나중에 사용하자는데 목적이 있다.
// 그리고 다음에 검색을 통해 식별자를 찾늗나. 식별자 해결은 등록과 검색으로 나눌 수 있다.
// 스코프는 식별자 해결을 위해 있는 것
// 스코프 예시 : 우리 나라에서 나를 찾는다. 이름을 검색 -> 동명이인이 많아 범위를 도 단위로 좁힌다 -> 시 단위로 좁힌다.

/* 스코프 설정 */
// 엔진이 function book(){}을 만나면 book function 오브젝트 생성
// 스코프를 설정 생성한 function 오브젝트의 [[Scope]]에 스코프를 설정 -> 이때 스코프가 결정된다. 
// 이렇게 function 오브젝트를 만드는 시점에 스코프를 결정하는 것을 정적 스코프라 한다.
// 함수를 호출할때 스코프를 결정하는 것을 동적 스코프라 한다.
// 동적스코프에서 함수를 만번 호출한다 가정하면 스코프를 만번을 만들어야한다.
// 반면, 정적스코프는 function오브젝트를 생성할때 그때 한번만 만들면되니까 1대 10000 이된다.
// 그래서 정적스코프가 동적스코프보다 효율성이 좋다.
function exam() {
  var point = 97;
  function get() {
    console.log(point);
  };
  get();
};
exam();
// 마지막 줄에서 book()함수를 호출하고 엔진 컨트롤이 book함수 안으로 이동한다.
// 함수 안에서 함수 선언문을 찾고 찾은 함수 선언문은 function 오브젝트 생성하며 스코프를 결정한다.

/* 글로벌 오브벡트 */
// 100을 value 변수에 할당하는 것은 value로 검색하여 값을 사용하기 위한 것
// 함수 안에 변수를 선언하면 변수가 함수에 속하게 되지만 (book 오브젝트에 point변수가 속하게 된다.)
// value변수를 함수 안에 작성하지 않았다 -> 오브젝트가 없다. -> 이때 글로벌 오브젝트에 설정
// 오브젝트가 하나이므로 굳이 오브젝트를 작성하지 않더라고 글로벌 오브젝트에 속하게 한다.(자체많으로는 좋은 조건) -> 그러나 지금은 많은 오브젝트를 사용하게 되고 그러다 보니 약간의 문제가 발생하긴한다.
// 오브젝트에 속하지 않으면 글로벌 오브젝트에 속하게 된다.
// JS소스 파일 전체에 글로벌 오브젝트는 하나만 있음 즉, new 연산자로 인스턴스 생성 불가
// JS소스 파일 전체 기준 : <script>에 작성된 모든 코드
// <script src="./abc.js">, <script src="./def.js"> 에 글로벌 오브젝트는 하나만 있다.(각각X, 둘이 합쳐 하나)
var value = 100;
function book() {
  var point = 200;
  return value;
};
book();

/* Global 스코프 */
// 글로벌 오브젝트가 글로벌 스코프! 글로벌 오브젝트가 하나만 있으니까 글로벌 스코프도 하나만 있따
// 오브젝트는 개발자 관점으로 오브젝트에 함수와 변수를 작성! 함수와 변수를 작성하기 위해서는 오브젝트가 있어야 한다
// 글로벌 오브젝트는 오브젝트가 없다. 물론 오브젝트는 없지만 호스트 오브젝트 개념으로 윈도우 오브젝트를 글로벌 오브젝트로 사용하긴 한다.
// 스코프는 식별자 해결을 위한 것으로 엔진 관점이다. 엔진이 식별자 해결을 위해 스코프를 사용한다.
// 글로벌 스코프는 최상위 스코프! 함수에서 보면 최종 스코프
// 식별자 해결을 위해 스코프를 계층적으로 따라 올라가다 마지막으로 만나는 것이 글로벌 스코프다.
var value = 100;
function book() {
  return value;
};
book();

/* 스코프 바인딩 */
// 구조적으로 결속된 상태로 만드는 것 대상: 프로퍼티(변수의 이름과 값, 함수의 이름과 값) 이름 -> 값은 변하므로 이름
// 바인딩 목적 : 스코프 설정, 식별자 해결
// 정적 바인딩(Lexical, Static) : 함수가 호출되었을때 초기화단계에서 바인딩, 함수선언문 이름을 바인딩, 표현식(변수, 함수) 이름을 바인딩 
// 동적 바인딩(Dynamio) : 실행 할 때 바인딩. eval() 함수(해석후 실행할때마다), with 문(반복할때마다)
// 바인딩 시점이 중요한 이유 : 바인딩할 때 스코프가 결정되기 때문!
// function 오브젝트 생성 시점에 스코프 결정! ★스코프가 변경되지 않음★
function soccer() {
  var score = 1;
  function add(param) {
    score += param;
  };
  var get = function (){
    return score;
  };
  add(2);
  console.log(get());
};
soccer();